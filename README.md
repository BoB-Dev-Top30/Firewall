# Firewall

# How to use
1. requirements.txt 에 해당하는 파일들을 설치한다.
2. 창을 열고 sudo -E env "PATH=$PATH" python3 Web_Firewall.py 명령어로 웹 방화벽을 실행한다.
3. 다른 창을 열고 python3 app.py 명령어로 플라스크 웹서버를 실행한다.
4. 로그대쉬보드의 경우 본웹서비스의 create를 통해 만들어야 시그니처넘버가 찍히고 그것을 기반으로 불러오기에 반드시 본서비스의 create를 이용하도록 한다.

# CRUD
## 1. Index Page(Read, Update, Delete, Unused Policy)
### 1> Read, Delete, Unused Policy
페이지에는 사용자가 체크박스를 선택하여 삭제와 업데이트를 수행할 수 있는 기능이 포함되어 있으며, 이 기능은 iptables의 'num'이라는 인덱스를 기반으로 한 알고리즘을 사용합니다. 삭제와 업데이트 기능을 사용하기 위해서는 사용자가 체크박스를 선택한 상태에서 POST 요청을 보내야 합니다. 이 과정은 JavaScript를 사용하여 구현되어 있어 사용자가 체크박스를 반드시 선택하도록 설계되었습니다. 특히, 사용자는 여러 체크박스를 한 번에 선택하여 삭제할 수 있으며, 삭제 시에는 iptables의 '-D' 옵션을 사용합니다. 또한 Unused 버튼을 통해 사용자는 실제로 사용하지 않고 있느 정책들을 필터링 할 수 있습니다.



### 2> Update
그러나 업데이트 기능은 한 번에 하나의 항목만 가능하도록 제한되어 있으며, 이 역시 JavaScript를 통해 구현되어 여러 체크박스 선택을 방지합니다.

'number' 필드와 'chain' 필드 같은 특정 항목들을 변경할 수 없습니다. 이들은 마치 프라이머리 키와 같은 역할을 하기 때문에, 프론트엔드에서 이 필드들을 읽기 전용으로 설정하여 사용자가 이를 변경하지 못하도록 합니다. 사용자가 나머지 값을 채우고 'Create' 버튼을 누르면, 선택된 'num' 필드의 값이 사용자가 입력한 새로운 정보로 업데이트됩니다. 이 과정에는 iptables의 '-R' 옵션이 사용됩니다.

## 2.  Create Page
사용자 입장에서 실제로 필요하고 자주 사용될 수 있는 핵심 요소들만을 포함시켰습니다. 또한, 프론트엔드에서는 JavaScript를 활용하여 CIDR을 포함한 IP 주소와 포트 번호의 유효성을 검증했습니다. 
# Monitoring
## 1. Network-State Page(Conntrack)
이 기능의 핵심은 사용자에게 중요한 정보를 필터링하여 보여주는 것에 있었습니다. 그래서 내부 프로세스 간 통신(ipc 통신)을 명시적으로 제외하고, 'established'와 'related' 상태에 있는 연결만을 필터링하도록 특정 명령어를 설정했습니다.
또한, 사용자가 필요한 정보를 쉽게 찾을 수 있도록 검색 기능을 추가했습니다. 이 기능은 테이블의 모든 열을 검사하여 사용자의 검색 조건과 일치하는 결과가 있을 때 해당 결과를 화면에 렌더링하도록 구성되어 있습니다. 이러한 방식으로, 사용자는 네트워크 상태 정보를 보다 효과적으로 모니터링 할 수 있습니다.
## 2. Dashboard Page(Log Info)
명확하고 직관적인 로그 분석을 위해, 다섯 가지 주요 파트로 구성된 대쉬보드를 제공하였습니다. 사용자는 비동기식으로 데이터를 요청하며, Flask 서버는 JSON 형태로 데이터를 응답합니다. 이 데이터는 레이블(label)과 값(value) 필드로 구성되어 있으며, 받아온 데이터를 기반으로 그래프를 작성하여 대쉬보드에 렌더링합니다.

데이터 전달을 위한 가공 과정은 필수적입니다. 이를 위해 log_parser라는 자체 제작 모듈을 통해 로그 데이터를 JSON 구조에 맞게 파싱하여 전달하도록 구현하였습니다. 이러한 접근 방식은 사용자가 로그 데이터를 보다 효과적으로 이해하고 분석할 수 있게 돕습니다.

# Deatail_Management
## 1. Packet Simulation
방화벽의 네트워크 정책의 매칭 여부를 확인하고 이를 바 그래프 형태로 시각화하는 기능이 주요 기능입니다. 이 과정을 위해 비동기식 통신이 필요하며, AJAX 방식을 사용하여 구현하였습니다. 처음에 사용자가 /packet_simulate 경로로 접속하면, GET 요청을 통해 packet_simulate.html 페이지가 렌더링됩니다.
<그림7>

사용자는 IP 주소를 입력하는 폼을 채우고, 같은 엔드포인트로 POST 요청을 보냅니다. 이후, Flask 서버는 JSON 데이터 형식으로 응답을 받아 처리합니다.
Match_Rule이라는 자체 개발된 모듈의 함수를 통해 매칭된 체인, 매칭되지 않은 체인, 그리고 각각의 개수를 반환합니다. 이 모듈은 해시 테이블과 인터벌 트리를 사용한 알고리즘을 기반으로 작동합니다.

서버에서 생성된 데이터는 프론트엔드로 전달되며, 데이터 전달 시 sort_keys=false 옵션을 사용하여 데이터가 키 기반으로 자동 정렬되지 않도록 합니다. 프론트엔드는 이 데이터를 바탕으로 기존의 그래프를 지우고 새로운 바 그래프를 그려 사용자에게 매칭된 정책과 매칭되지 않은 정책의 개수를 시각적으로 보여줍니다.
<그림8>

또한, 사용자는 두 개의 버튼을 통해 매칭된 정책과 매칭되지 않은 정책을 볼 수 있습니다. 이 버튼들은 JavaScript를 사용하여 동적으로 생성되며, 기존 버튼이 있을 경우 제거한 후 새로 만들어 항상 두 개의 버튼이 유지되도록 설계되었습니다. 이러한 방식으로 사용자는 매칭 여부에 따른 정책들을 더욱 효과적으로 확인하고 분석할 수 있습니다.

각각의 버튼은 사용자를 다른 엔드포인트로 안내하는 역할을 하며, 버튼 클릭 시 matched_chain 또는 unmatched_chain 데이터(리스트 형태)를 각각 ./matched나 ./unmatched 엔드포인트로 POST 요청을 통해 전송합니다. 이러한 요청은 Flask 서버에서 데이터 형식을 재구성하는 목적으로 사용됩니다.

마지막은 /match_table로 요청을 보내줍니다.
<그림9>
## 2. Web-Firewall

Linux의 NetfilterQueue를 사용하여, 패킷을 인터셉트하고 사용자 정의 함수(process_packet)로 전달합니다. Scapy를 이용해 가로챈 패킷에서 소스 및 목적지 IP, 포트 번호, 프로토콜 정보를 추출합니다. 특히, HTTP 프로토콜을 사용하는 패킷의 내용을 분석하여 GET 및 POST 요청을 확인합니다. 제작한 모듈(DP_Xss, DP_Sql_Injection)을 통해 XSS 및 SQL 인젝션 공격 패턴을 감지합니다. 이 과정에서 감지된 공격 유형에 따라 해당 패킷을 수정하거나, 공격 정보를 로깅합니다. 공격이 감지되면, 공격 유형, 소스 및 목적지 정보, 프로토콜, 공격 횟수 등의 상세 정보를 로그 파일에 기록합니다. 이를 통해 대쉬보드 형태의 서비스를 제공하도록 합니다. 감지된 보안 위협에 대응하여 안전하게 수정된 패킷으로 원본 패킷을 교체한 후, 네트워크로 다시 전송합니다. 스크립트는 사용자가 종료 요청을 할 때까지 넷필터 큐를 통해 패킷을 처리하는 루프에서 실행됩니다. 사용자가 종료(예: 키보드 인터럽트)를 요청하면, 넷필터 큐 바인딩을 해제하고 스크립트를 안전하게 종료합니다.

<그림12>

<그림13>

<그림14>

<그림15>
